{"name": "test_1", "status": "broken", "statusDetails": {"message": "requests.exceptions.ChunkedEncodingError: ('Connection broken: IncompleteRead(0 bytes read, 8387 more expected)', IncompleteRead(0 bytes read, 8387 more expected))", "trace": "self = <urllib3.response.HTTPResponse object at 0x00000200D4ADBE20>\n\n    @contextmanager\n    def _error_catcher(self) -> typing.Generator[None, None, None]:\n        \"\"\"\n        Catch low-level python exceptions, instead re-raising urllib3\n        variants, so that low-level exceptions are not leaked in the\n        high-level api.\n    \n        On exit, release the connection back to the pool.\n        \"\"\"\n        clean_exit = False\n    \n        try:\n            try:\n>               yield\n\n..\\..\\..\\..\\miniconda3\\Lib\\site-packages\\urllib3\\response.py:710: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <urllib3.response.HTTPResponse object at 0x00000200D4ADBE20>, amt = 10240\n\n    def _raw_read(\n        self,\n        amt: int | None = None,\n    ) -> bytes:\n        \"\"\"\n        Reads `amt` of bytes from the socket.\n        \"\"\"\n        if self._fp is None:\n            return None  # type: ignore[return-value]\n    \n        fp_closed = getattr(self._fp, \"closed\", False)\n    \n        with self._error_catcher():\n            data = self._fp_read(amt) if not fp_closed else b\"\"\n            if amt is not None and amt != 0 and not data:\n                # Platform-specific: Buggy versions of Python.\n                # Close the connection when no data is returned\n                #\n                # This is redundant to what httplib/http.client _should_\n                # already do.  However, versions of python released before\n                # December 15, 2012 (http://bugs.python.org/issue16298) do\n                # not properly close the connection in all cases. There is\n                # no harm in redundantly calling close.\n                self._fp.close()\n                if (\n                    self.enforce_content_length\n                    and self.length_remaining is not None\n                    and self.length_remaining != 0\n                ):\n                    # This is an edge case that httplib failed to cover due\n                    # to concerns of backward compatibility. We're\n                    # addressing it here to make sure IncompleteRead is\n                    # raised during streaming, so all calls with incorrect\n                    # Content-Length are caught.\n>                   raise IncompleteRead(self._fp_bytes_read, self.length_remaining)\nE                   urllib3.exceptions.IncompleteRead: IncompleteRead(0 bytes read, 8387 more expected)\n\n..\\..\\..\\..\\miniconda3\\Lib\\site-packages\\urllib3\\response.py:835: IncompleteRead\n\nThe above exception was the direct cause of the following exception:\n\n    def generate():\n        # Special case for urllib3.\n        if hasattr(self.raw, \"stream\"):\n            try:\n>               yield from self.raw.stream(chunk_size, decode_content=True)\n\n..\\..\\..\\..\\miniconda3\\Lib\\site-packages\\requests\\models.py:820: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n..\\..\\..\\..\\miniconda3\\Lib\\site-packages\\urllib3\\response.py:940: in stream\n    data = self.read(amt=amt, decode_content=decode_content)\n..\\..\\..\\..\\miniconda3\\Lib\\site-packages\\urllib3\\response.py:879: in read\n    data = self._raw_read(amt)\n..\\..\\..\\..\\miniconda3\\Lib\\site-packages\\urllib3\\response.py:813: in _raw_read\n    with self._error_catcher():\n..\\..\\..\\..\\miniconda3\\Lib\\contextlib.py:158: in __exit__\n    self.gen.throw(value)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <urllib3.response.HTTPResponse object at 0x00000200D4ADBE20>\n\n    @contextmanager\n    def _error_catcher(self) -> typing.Generator[None, None, None]:\n        \"\"\"\n        Catch low-level python exceptions, instead re-raising urllib3\n        variants, so that low-level exceptions are not leaked in the\n        high-level api.\n    \n        On exit, release the connection back to the pool.\n        \"\"\"\n        clean_exit = False\n    \n        try:\n            try:\n                yield\n    \n            except SocketTimeout as e:\n                # FIXME: Ideally we'd like to include the url in the ReadTimeoutError but\n                # there is yet no clean way to get at it from this context.\n                raise ReadTimeoutError(self._pool, None, \"Read timed out.\") from e  # type: ignore[arg-type]\n    \n            except BaseSSLError as e:\n                # FIXME: Is there a better way to differentiate between SSLErrors?\n                if \"read operation timed out\" not in str(e):\n                    # SSL errors related to framing/MAC get wrapped and reraised here\n                    raise SSLError(e) from e\n    \n                raise ReadTimeoutError(self._pool, None, \"Read timed out.\") from e  # type: ignore[arg-type]\n    \n            except (HTTPException, OSError) as e:\n                # This includes IncompleteRead.\n>               raise ProtocolError(f\"Connection broken: {e!r}\", e) from e\nE               urllib3.exceptions.ProtocolError: ('Connection broken: IncompleteRead(0 bytes read, 8387 more expected)', IncompleteRead(0 bytes read, 8387 more expected))\n\n..\\..\\..\\..\\miniconda3\\Lib\\site-packages\\urllib3\\response.py:727: ProtocolError\n\nDuring handling of the above exception, another exception occurred:\n\nrequest = <SubRequest 'get_driver' for <Function test_1>>\n\n    @pytest.fixture(autouse=True)\n    def get_driver(request):\n>       service = Service(executable_path=ChromeDriverManager().install())\n\n..\\..\\conftest.py:28: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n..\\..\\..\\..\\miniconda3\\Lib\\site-packages\\webdriver_manager\\chrome.py:40: in install\n    driver_path = self._get_driver_binary_path(self.driver)\n..\\..\\..\\..\\miniconda3\\Lib\\site-packages\\webdriver_manager\\core\\manager.py:35: in _get_driver_binary_path\n    binary_path = self._cache_manager.find_driver(driver)\n..\\..\\..\\..\\miniconda3\\Lib\\site-packages\\webdriver_manager\\core\\driver_cache.py:110: in find_driver\n    key = self.__get_metadata_key(driver)\n..\\..\\..\\..\\miniconda3\\Lib\\site-packages\\webdriver_manager\\core\\driver_cache.py:144: in __get_metadata_key\n    driver_version = self.get_cache_key_driver_version(driver)\n..\\..\\..\\..\\miniconda3\\Lib\\site-packages\\webdriver_manager\\core\\driver_cache.py:154: in get_cache_key_driver_version\n    return driver.get_driver_version_to_download()\n..\\..\\..\\..\\miniconda3\\Lib\\site-packages\\webdriver_manager\\core\\driver.py:48: in get_driver_version_to_download\n    return self.get_latest_release_version()\n..\\..\\..\\..\\miniconda3\\Lib\\site-packages\\webdriver_manager\\drivers\\chrome.py:60: in get_latest_release_version\n    response_dict = json.loads(response.text)\n..\\..\\..\\..\\miniconda3\\Lib\\site-packages\\requests\\models.py:926: in text\n    if not self.content:\n..\\..\\..\\..\\miniconda3\\Lib\\site-packages\\requests\\models.py:902: in content\n    self._content = b\"\".join(self.iter_content(CONTENT_CHUNK_SIZE)) or b\"\"\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\n    def generate():\n        # Special case for urllib3.\n        if hasattr(self.raw, \"stream\"):\n            try:\n                yield from self.raw.stream(chunk_size, decode_content=True)\n            except ProtocolError as e:\n>               raise ChunkedEncodingError(e)\nE               requests.exceptions.ChunkedEncodingError: ('Connection broken: IncompleteRead(0 bytes read, 8387 more expected)', IncompleteRead(0 bytes read, 8387 more expected))\n\n..\\..\\..\\..\\miniconda3\\Lib\\site-packages\\requests\\models.py:822: ChunkedEncodingError"}, "start": 1732550774239, "stop": 1732550774239, "uuid": "eb5f729d-8505-4b44-a996-62c3587f37e7", "historyId": "8497edc69ccffae71367a04ec244b0f1", "testCaseId": "8497edc69ccffae71367a04ec244b0f1", "fullName": "Tests.homework.module_5.TestValidate#test_1", "labels": [{"name": "parentSuite", "value": "Tests.homework"}, {"name": "suite", "value": "module_5"}, {"name": "subSuite", "value": "TestValidate"}, {"name": "host", "value": "Admin"}, {"name": "thread", "value": "14200-MainThread"}, {"name": "framework", "value": "pytest"}, {"name": "language", "value": "cpython3"}, {"name": "package", "value": "Tests.homework.module_5"}]}