{"name": "test_apply_promo_code_3", "status": "broken", "statusDetails": {"message": "requests.exceptions.ChunkedEncodingError: ('Connection broken: IncompleteRead(16384 bytes read, 59595 more expected)', IncompleteRead(16384 bytes read, 59595 more expected))", "trace": "self = <urllib3.response.HTTPResponse object at 0x000001985444F580>\n\n    @contextmanager\n    def _error_catcher(self) -> typing.Generator[None, None, None]:\n        \"\"\"\n        Catch low-level python exceptions, instead re-raising urllib3\n        variants, so that low-level exceptions are not leaked in the\n        high-level api.\n    \n        On exit, release the connection back to the pool.\n        \"\"\"\n        clean_exit = False\n    \n        try:\n            try:\n>               yield\n\n..\\..\\..\\..\\miniconda3\\Lib\\site-packages\\urllib3\\response.py:710: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <urllib3.response.HTTPResponse object at 0x000001985444F580>, amt = 10240\n\n    def _raw_read(\n        self,\n        amt: int | None = None,\n    ) -> bytes:\n        \"\"\"\n        Reads `amt` of bytes from the socket.\n        \"\"\"\n        if self._fp is None:\n            return None  # type: ignore[return-value]\n    \n        fp_closed = getattr(self._fp, \"closed\", False)\n    \n        with self._error_catcher():\n            data = self._fp_read(amt) if not fp_closed else b\"\"\n            if amt is not None and amt != 0 and not data:\n                # Platform-specific: Buggy versions of Python.\n                # Close the connection when no data is returned\n                #\n                # This is redundant to what httplib/http.client _should_\n                # already do.  However, versions of python released before\n                # December 15, 2012 (http://bugs.python.org/issue16298) do\n                # not properly close the connection in all cases. There is\n                # no harm in redundantly calling close.\n                self._fp.close()\n                if (\n                    self.enforce_content_length\n                    and self.length_remaining is not None\n                    and self.length_remaining != 0\n                ):\n                    # This is an edge case that httplib failed to cover due\n                    # to concerns of backward compatibility. We're\n                    # addressing it here to make sure IncompleteRead is\n                    # raised during streaming, so all calls with incorrect\n                    # Content-Length are caught.\n>                   raise IncompleteRead(self._fp_bytes_read, self.length_remaining)\nE                   urllib3.exceptions.IncompleteRead: IncompleteRead(16384 bytes read, 59595 more expected)\n\n..\\..\\..\\..\\miniconda3\\Lib\\site-packages\\urllib3\\response.py:835: IncompleteRead\n\nThe above exception was the direct cause of the following exception:\n\n    def generate():\n        # Special case for urllib3.\n        if hasattr(self.raw, \"stream\"):\n            try:\n>               yield from self.raw.stream(chunk_size, decode_content=True)\n\n..\\..\\..\\..\\miniconda3\\Lib\\site-packages\\requests\\models.py:820: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n..\\..\\..\\..\\miniconda3\\Lib\\site-packages\\urllib3\\response.py:940: in stream\n    data = self.read(amt=amt, decode_content=decode_content)\n..\\..\\..\\..\\miniconda3\\Lib\\site-packages\\urllib3\\response.py:879: in read\n    data = self._raw_read(amt)\n..\\..\\..\\..\\miniconda3\\Lib\\site-packages\\urllib3\\response.py:813: in _raw_read\n    with self._error_catcher():\n..\\..\\..\\..\\miniconda3\\Lib\\contextlib.py:158: in __exit__\n    self.gen.throw(value)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <urllib3.response.HTTPResponse object at 0x000001985444F580>\n\n    @contextmanager\n    def _error_catcher(self) -> typing.Generator[None, None, None]:\n        \"\"\"\n        Catch low-level python exceptions, instead re-raising urllib3\n        variants, so that low-level exceptions are not leaked in the\n        high-level api.\n    \n        On exit, release the connection back to the pool.\n        \"\"\"\n        clean_exit = False\n    \n        try:\n            try:\n                yield\n    \n            except SocketTimeout as e:\n                # FIXME: Ideally we'd like to include the url in the ReadTimeoutError but\n                # there is yet no clean way to get at it from this context.\n                raise ReadTimeoutError(self._pool, None, \"Read timed out.\") from e  # type: ignore[arg-type]\n    \n            except BaseSSLError as e:\n                # FIXME: Is there a better way to differentiate between SSLErrors?\n                if \"read operation timed out\" not in str(e):\n                    # SSL errors related to framing/MAC get wrapped and reraised here\n                    raise SSLError(e) from e\n    \n                raise ReadTimeoutError(self._pool, None, \"Read timed out.\") from e  # type: ignore[arg-type]\n    \n            except (HTTPException, OSError) as e:\n                # This includes IncompleteRead.\n>               raise ProtocolError(f\"Connection broken: {e!r}\", e) from e\nE               urllib3.exceptions.ProtocolError: ('Connection broken: IncompleteRead(16384 bytes read, 59595 more expected)', IncompleteRead(16384 bytes read, 59595 more expected))\n\n..\\..\\..\\..\\miniconda3\\Lib\\site-packages\\urllib3\\response.py:727: ProtocolError\n\nDuring handling of the above exception, another exception occurred:\n\npytestconfig = <_pytest.config.Config object at 0x0000019852895070>\n\n    @pytest.fixture()\n    def get_driver(pytestconfig):\n>       service = Service(executable_path=ChromeDriverManager().install())\n\n..\\..\\src\\fixtures\\system\\browser.py:36: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n..\\..\\..\\..\\miniconda3\\Lib\\site-packages\\webdriver_manager\\chrome.py:40: in install\n    driver_path = self._get_driver_binary_path(self.driver)\n..\\..\\..\\..\\miniconda3\\Lib\\site-packages\\webdriver_manager\\core\\manager.py:40: in _get_driver_binary_path\n    file = self._download_manager.download_file(driver.get_driver_download_url(os_type))\n..\\..\\..\\..\\miniconda3\\Lib\\site-packages\\webdriver_manager\\drivers\\chrome.py:45: in get_driver_download_url\n    modern_version_url = self.get_url_for_version_and_platform(driver_version_to_download, os_type)\n..\\..\\..\\..\\miniconda3\\Lib\\site-packages\\webdriver_manager\\drivers\\chrome.py:76: in get_url_for_version_and_platform\n    data = response.json()\n..\\..\\..\\..\\miniconda3\\Lib\\site-packages\\requests\\models.py:974: in json\n    return complexjson.loads(self.text, **kwargs)\n..\\..\\..\\..\\miniconda3\\Lib\\site-packages\\requests\\models.py:926: in text\n    if not self.content:\n..\\..\\..\\..\\miniconda3\\Lib\\site-packages\\requests\\models.py:902: in content\n    self._content = b\"\".join(self.iter_content(CONTENT_CHUNK_SIZE)) or b\"\"\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\n    def generate():\n        # Special case for urllib3.\n        if hasattr(self.raw, \"stream\"):\n            try:\n                yield from self.raw.stream(chunk_size, decode_content=True)\n            except ProtocolError as e:\n>               raise ChunkedEncodingError(e)\nE               requests.exceptions.ChunkedEncodingError: ('Connection broken: IncompleteRead(16384 bytes read, 59595 more expected)', IncompleteRead(16384 bytes read, 59595 more expected))\n\n..\\..\\..\\..\\miniconda3\\Lib\\site-packages\\requests\\models.py:822: ChunkedEncodingError"}, "attachments": [{"name": "log", "source": "9137ac1c-b0d2-4be1-b4a9-340f52e6cb6e-attachment.txt", "type": "text/plain"}], "start": 1738077563217, "stop": 1738077563217, "uuid": "d0bdc587-6623-43c2-af68-6d824496213d", "historyId": "4d3e7211570903f0b6223686b47abcb9", "testCaseId": "4d3e7211570903f0b6223686b47abcb9", "fullName": "Tests.homework.final_work.TestValidate#test_apply_promo_code_3", "labels": [{"name": "story", "value": "Waiting page load"}, {"name": "feature", "value": "Full Accounts"}, {"name": "parentSuite", "value": "Tests.homework"}, {"name": "suite", "value": "final_work"}, {"name": "subSuite", "value": "TestValidate"}, {"name": "host", "value": "Admin"}, {"name": "thread", "value": "692-MainThread"}, {"name": "framework", "value": "pytest"}, {"name": "language", "value": "cpython3"}, {"name": "package", "value": "Tests.homework.final_work"}]}